<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Sketchfab + Local PLY Annotator</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    #ui { position: absolute; z-index: 20; left: 8px; top: 8px; display: flex; gap:8px; align-items:center; }
    #viewer, #localViewer { width: 100vw; height: 100vh; background:#000; }
    #localViewer { display:none; position: absolute; inset:0; z-index:10; }
    iframe { border: 0; width:100%; height:100%; display:block; }
    .label {
      position: absolute;
      transform: translate(-50%,-100%);
      background: rgba(0,0,0,0.75);
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      pointer-events: auto;
      font-size: 13px;
      max-width:240px;
      white-space: pre-wrap;
    }
    .rect-select {
      position: absolute;
      border: 1px dashed #0ff;
      background: rgba(0,255,255,0.06);
      pointer-events: none;
      z-index: 30;
    }
  </style>
</head>
<body>
  <div id="ui">
    <input id="UID" placeholder="حط هنا الـ UID بتاع موديلك من Sketchfab" style="padding:6px" />
    <button id="loadSketchfab">عرض الموديل (Sketchfab)</button>
    <button id="openLocal">فتح المحرر المحلي (PLY)</button>
    <input id="plyFile" type="file" accept=".ply" style="display:none" />
    <button id="loadLocalBtn" style="display:none">Load .ply file</button>
    <a href="./UploadeToSketchfad.html">
      <button>UploadeToSketchfad</button>
    </a>
    <small>  • Left click: annotate point • Shift+drag: select area • Esc: clear selection</small>
  </div>

  <div id="viewer"></div>
  <div id="localViewer"></div>

  <script src="https://static.sketchfab.com/api/sketchfab-viewer-1.12.1.js"></script>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.152.2/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js";
    import { PLYLoader } from "https://unpkg.com/three@0.152.2/examples/jsm/loaders/PLYLoader.js";

    // Sketchfab section
    const viewer = document.getElementById('viewer');
    const localViewer = document.getElementById('localViewer');
    const uidInput = document.getElementById('UID');
    const loadSketchfabBtn = document.getElementById('loadSketchfab');
    const openLocalBtn = document.getElementById('openLocal');
    const plyFileInput = document.getElementById('plyFile');
    const loadLocalBtn = document.getElementById('loadLocalBtn');

    let sketchfabIframe = null;
    let sketchfabClient = null;

    loadSketchfabBtn.addEventListener('click', () => {
      const uid = uidInput.value.trim();
      if (!uid) { alert("من فضلك حط الـ UID"); return; }
      viewer.innerHTML = '';
      sketchfabIframe = document.createElement('iframe');
      sketchfabIframe.setAttribute('allow', 'autoplay; fullscreen; vr');
      sketchfabIframe.style.width = '100%';
      sketchfabIframe.style.height = '100%';
      viewer.appendChild(sketchfabIframe);

      sketchfabClient = new Sketchfab('1.12.1', sketchfabIframe);
      sketchfabClient.init(uid, {
        success: function(api) {
          api.start(() => {});
          api.addEventListener('viewerready', () => {
            console.log('Sketchfab ready');
            // simple camera fit example
            api.setCameraLookAt([0,0,3],[0,0,0], 0);
          });
        },
        error: function() { console.error('Sketchfab error'); }
      });

      // Show viewer and hide local editor
      viewer.style.display = 'block';
      localViewer.style.display = 'none';
    });

    // Local PLY annotator section
    openLocalBtn.addEventListener('click', () => {
      viewer.style.display = 'none';
      localViewer.style.display = 'block';
      document.getElementById('plyFile').click();
    });

    plyFileInput.addEventListener('change', (e) => {
      if (e.target.files && e.target.files[0]) loadLocalPLY(e.target.files[0]);
    });

    // Core local viewer state
    let scene, camera, renderer, controls, mesh, annotations = [], labelsContainer;
    let raycaster = new THREE.Raycaster();
    let pointer = new THREE.Vector2();
    let selecting = false, selectStart = null, rectEl = null;

    function setupLocalViewer() {
      if (renderer) return; // already initialized
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x222233);

      camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.001, 1000000);
      camera.position.set(0.7,0.6,0.7);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio,2));
      localViewer.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const hemi = new THREE.HemisphereLight(0xffffff,0x444444,1.0);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff,0.8);
      dir.position.set(2,3,1);
      scene.add(dir);

      labelsContainer = document.createElement('div');
      labelsContainer.style.position = 'absolute';
      labelsContainer.style.left = '0';
      labelsContainer.style.top = '0';
      labelsContainer.style.pointerEvents = 'none';
      labelsContainer.style.zIndex = 40;
      document.body.appendChild(labelsContainer);

      window.addEventListener('resize', onWindowResize);
      renderer.domElement.addEventListener('pointerdown', onPointerDown);
      renderer.domElement.addEventListener('pointerup', onPointerUp);
      renderer.domElement.addEventListener('pointermove', onPointerMove);
      window.addEventListener('keydown', (e) => { if (e.key === 'Escape') clearSelection(); });

      animate();
    }

    function onWindowResize() {
      if (!camera || !renderer) return;
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    }

    function loadLocalPLY(file) {
      setupLocalViewer();
      const reader = new FileReader();
      reader.onload = function(ev) {
        const content = ev.target.result;
        const loader = new PLYLoader();
        // PLYLoader supports ArrayBuffer; detect
        let geometry;
        try {
          geometry = loader.parse(content);
        } catch (err) {
          // try text
          geometry = loader.parse(new TextEncoder().encode(content));
        }
        geometry.computeVertexNormals();
        geometry.center();
        const mat = new THREE.MeshStandardMaterial({ color:0x8c8c8c, flatShading:false, metalness:0.1, roughness:0.6 });
        if (mesh) { scene.remove(mesh); mesh.geometry.dispose(); mesh.material.dispose(); }
        mesh = new THREE.Mesh(geometry, mat);
        scene.add(mesh);
        fitCameraToObject(mesh);
        annotations.length = 0; // clear
        clearAllLabels();
      };
      // read as ArrayBuffer if binary; otherwise text
      const isBinary = file.name.toLowerCase().endsWith('.ply'); // assume text or binary; read as ArrayBuffer then parse
      reader.readAsArrayBuffer(file);
    }

    function fitCameraToObject(object, { fitOffset = 1.2 } = {}) {
      if (!object) return;
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      const maxSize = Math.max(size.x, size.y, size.z);
      const fitHeightDistance = maxSize / (2 * Math.atan(Math.PI * camera.fov / 360));
      const fitWidthDistance = fitHeightDistance / camera.aspect;
      const distance = fitOffset * Math.max(fitHeightDistance, fitWidthDistance);

      camera.position.copy(center).add(new THREE.Vector3(distance,distance,distance));
      camera.near = Math.max(0.001, distance / 1000);
      camera.far = Math.max(1e6, distance * 1000);
      camera.updateProjectionMatrix();
      controls.target.copy(center);
      controls.update();
    }

    function animate() {
      requestAnimationFrame(animate);
      controls?.update();
      updateLabels();
      renderer?.render(scene, camera);
    }

    // Utilities: project world->screen
    function worldToScreen(pos) {
      const vec = pos.clone().project(camera);
      const x = (vec.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
      const y = ( -vec.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
      return new THREE.Vector2(x, y);
    }

    // Find nearest vertex to world intersection point
    function findNearestVertex(worldPoint) {
      if (!mesh || !mesh.geometry || !mesh.geometry.attributes.position) return null;
      const posAttr = mesh.geometry.attributes.position;
      const v = new THREE.Vector3();
      let bestIdx = -1, bestDist = Infinity;
      for (let i = 0; i < posAttr.count; i++) {
        v.fromBufferAttribute(posAttr, i);
        mesh.localToWorld(v);
        const d = v.distanceToSquared(worldPoint);
        if (d < bestDist) { bestDist = d; bestIdx = i; }
      }
      if (bestIdx === -1) return null;
      const out = new THREE.Vector3().fromBufferAttribute(posAttr, bestIdx);
      mesh.localToWorld(out);
      return { index: bestIdx, position: out };
    }

    // Annotations (store world positions and text)
    function addAnnotation(worldPos, text, indices = null) {
      const id = Date.now().toString(36);
      annotations.push({ id, position: worldPos.clone(), text, indices });
      createLabel(id, worldPos, text);
    }

    function createLabel(id, worldPos, text) {
      const el = document.createElement('div');
      el.className = 'label';
      el.dataset.id = id;
      el.innerText = text;
      el.style.pointerEvents = 'auto';
      el.addEventListener('click', (e) => {
        e.stopPropagation();
        const a = annotations.find(x=>x.id===id);
        const newText = prompt('Edit annotation text:', a.text);
        if (newText !== null) {
          a.text = newText;
          el.innerText = newText;
        }
      });
      labelsContainer.appendChild(el);
      positionLabelElement(el, worldPos);
    }

    function positionLabelElement(el, worldPos) {
      if (!camera) return;
      const screen = worldToScreen(worldPos);
      el.style.left = `${screen.x}px`;
      el.style.top = `${screen.y}px`;
      // hide if behind camera
      const v = worldPos.clone().project(camera);
      el.style.display = (v.z > 1 || v.z < -1) ? 'none' : 'block';
    }

    function updateLabels() {
      // reposition all labels each frame
      for (const a of annotations) {
        const el = labelsContainer.querySelector(`[data-id="${a.id}"]`);
        if (el) positionLabelElement(el, a.position);
      }
      // also ensure labelsContainer fills viewport so absolute coords work
      labelsContainer.style.width = innerWidth + 'px';
      labelsContainer.style.height = innerHeight + 'px';
    }

    function clearAllLabels() {
      labelsContainer && (labelsContainer.innerHTML = '');
    }

    function clearSelection() {
      if (rectEl) { rectEl.remove(); rectEl = null; selecting = false; }
    }

    // Pointer handlers: click to annotate a point, shift+drag to select area
    function getPointerClientXY(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      return { x: event.clientX - rect.left, y: event.clientY - rect.top };
    }

    function onPointerDown(event) {
      if (!mesh) return;
      if (event.shiftKey) {
        selecting = true;
        selectStart = getPointerClientXY(event);
        rectEl = document.createElement('div');
        rectEl.className = 'rect-select';
        rectEl.style.left = `${selectStart.x}px`;
        rectEl.style.top = `${selectStart.y}px`;
        rectEl.style.width = '0px';
        rectEl.style.height = '0px';
        document.body.appendChild(rectEl);
        return;
      }
      // regular click: raycast and annotate nearest vertex
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObject(mesh, false);
      if (intersects.length > 0) {
        const worldPoint = intersects[0].point;
        const nearest = findNearestVertex(worldPoint) || { position: worldPoint, index: null };
        const text = prompt("Enter annotation text:");
        if (text) addAnnotation(nearest.position, text, nearest.index !== null ? [nearest.index] : null);
      }
    }

    function onPointerMove(event) {
      if (!selecting || !rectEl) return;
      const p = getPointerClientXY(event);
      const x = Math.min(p.x, selectStart.x);
      const y = Math.min(p.y, selectStart.y);
      const w = Math.abs(p.x - selectStart.x);
      const h = Math.abs(p.y - selectStart.y);
      rectEl.style.left = `${x}px`;
      rectEl.style.top = `${y}px`;
      rectEl.style.width = `${w}px`;
      rectEl.style.height = `${h}px`;
    }

    function onPointerUp(event) {
      if (!selecting) return;
      selecting = false;
      const rectBounds = rectEl.getBoundingClientRect();
      // project all vertices and collect indices inside rect
      if (mesh && mesh.geometry && mesh.geometry.attributes.position) {
        const posAttr = mesh.geometry.attributes.position;
        const selectedIndices = [];
        const tmp = new THREE.Vector3();
        for (let i = 0; i < posAttr.count; i++) {
          tmp.fromBufferAttribute(posAttr, i);
          mesh.localToWorld(tmp);
          const screen = worldToScreen(tmp);
          const clientX = screen.x;
          const clientY = screen.y;
          // coordinates relative to window; rectBounds already in window coords
          const rectLeft = rectBounds.left;
          const rectTop = rectBounds.top;
          if (clientX >= rectLeft && clientX <= rectLeft + rectBounds.width &&
              clientY >= rectTop && clientY <= rectTop + rectBounds.height) {
            selectedIndices.push(i);
          }
        }
        if (selectedIndices.length > 0) {
          // compute centroid
          const centroid = new THREE.Vector3();
          const tmp2 = new THREE.Vector3();
          for (const idx of selectedIndices) {
            tmp2.fromBufferAttribute(mesh.geometry.attributes.position, idx);
            mesh.localToWorld(tmp2);
            centroid.add(tmp2);
          }
          centroid.divideScalar(selectedIndices.length);
          const text = prompt(`Annotation for ${selectedIndices.length} vertices:`);
          if (text) addAnnotation(centroid, text, selectedIndices);
        } else {
          alert('No vertices found inside selection.');
        }
      }
      rectEl.remove();
      rectEl = null;
    }

    // start the local viewer if user drops a file or chooses to open
    // keep the rest of the page interactive
    // expose loadLocalPLY to global for quick debugging
    window.loadLocalPLY = loadLocalPLY;
  </script>
</body>
</html>
